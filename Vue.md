# 2 Vue

<hr>

## 2.1 说说你对vue的理解？
vue是一个渐进式前端框架，使用vue可以使得我们无需关注DOM渲染，只关心数据即可，因为vue是数据驱动视图的，这里的数据驱动指的就是MVVM

MVVM介绍：
  - M指的是Model，Model当中存放了我们的数据和业务
  - V指的是View，即视图，也就是我们展示在浏览器当中的页面
  - VM指的是视图模型，VM连接了Model和View，使得这两者可以进行通信，这里的VM指的就是vue

组件化的优势：
  1. 降低耦合度，使得代码可以更容易被复用，高内聚低耦合
  2. 维护性好，组件的职责是单一的，并且是复用的，维护起来比较方便

<hr>

## 2.2 说说你对vue响应式原理的理解？
vue当中，数据发生变化，会驱动视图发生改变，用户在视图当中修改，会触发数据的改变，这是MVMM当中核心的概念。

vue当中的响应式原理大致可以分为两个步骤：
  1. 数据劫持
  vue2当中，实现数据的劫持是通过Object.defineProperty当中的getter、setter和重写数组方法的方式来实现的，兼容性比较好，兼容了IE；在vue3当中，使用了proxy代理来实现了数据的劫持，不再兼任IE浏览器
  2. 发布订阅
  当实现了数据监听和劫持之后，vue通过发布订阅者模式，维护了一个订阅者数组。当我们在JS当中修改数据时，vue会通知订阅了此数据的全部订阅者进行视图的更新；当用户在页面上修改了之后，也会触发数据的更改，vue同样也会进行通知订阅者进行视图的更改。

订阅者是一个概念，它是用于管理更新视图的对象，当数据发生变化的时候，vue会通知所有的订阅者进行视图的更新，每一个挂载在页面上的组件都可以看作是一个订阅者，它们订阅了某个数据的变化，并且等待数据发生变化时进行视图的更新

<hr>

## 2.3 说说你对SPA（单页应用）的理解？
单页面应用即single page application，指的是用户的交互、页面数据的更新、系统当中模块的变换都在一个html页面当中，并不涉及多个页面的切换。

单页面应用的缺点：
1. 不利于SEO优化
2. 首屏加载速度慢

单页面应用的优点：
1. 用户体验好，无需切换多个页面
2. 前后端分离，分工明确

React和Vue都可以创建单页面应用，单页面应用创建的核心原理在于路由，路由有两种模式，分别未hash和history模式，hash模式下，可以监听hash值的变化，根据hash值来动态展示页面上的组件；history模式则是利用的window.history对象来实现页面的动态展示

单页面应用做SEO优化：
1. SSR服务端渲染
2. 在服务器上保存一个静态页面，此静态页面暴露给外部，当外部访问的时候，再通过路径重写，转到动态页面上

<hr>

## 2.4 Vue中的v-show和v-if怎么理解？
v-show和v-if都是条件渲染的指令，相同点是都可以实现元素的条件渲染，不同点如下：
1. 实现的原理不同，v-show只是通过切换CSS的display属性来显示和隐藏，v-if则是在编译阶段进行判断是否进行编译，v-if是真正的条件渲染。
2. 性能消耗不同，v-show的初始化渲染性能消耗大，v-if的切换性能消耗大

在使用时，如果一个元素可能会频繁显示隐藏时，使用v-show，减少切换时的性能消耗；如果一个元素在初始化之后，基本不会进行显示隐藏的切换，则使用v-if，减少初始化渲染性能

<hr>

## 2.5 Vue实例挂载的过程中发生了什么？

<hr>

## 2.6 说说你对Vue生命周期的理解？
vue的生命周期可以分为四个阶段，分别为创建、挂载、更新、卸载，这四个阶段之前和之后，一共8个生命周期函数

常规生命周期函数：
  - beforeCreate
    > 组件创建之前，此时无法访问到data和method
  - created
    > 组件创建完成，此时可以访问到data和method，一般可以在created进行数据的请求
  - beforeMount
    > 组件挂载之前，此时虚拟dom已经生成，但是还未挂载到页面当中，无法操作真实dom
  - mounted
    > 组件挂载完成，此时可以访问和操作真实dom
  - beforeUpdate
    > 组件更新之前，此时data当中的数据是最新的，页面上的还是旧的数据
  - updated
    > 组件更新完成，此时data和页面上的数据都是最新的
  - beforeDestroy
    > 组件即将卸载，此时组件内的data和method等，都还处于可用状态，一般在beforeDestroy当中进行取消监听、解绑事件等收尾工作
  - destroyed
    > 组件完全被销毁，组件内的数据和方法都不可再使用

当使用keep-alive包裹了组件后，被包裹的组件就会多出两个生命周期函数：activated和deactivated
  - activated
    > 缓存的组件激活时，触发activated
  - deactivated
    > 缓存的组件失活时，触发deactivated

当子组件的出现错误，被父组件捕捉到时，会调用errorCaptured
  - errorCaptured
    > 捕获一个来自子孙组件的错误时被调用

<hr>

## 2.7 为什么Vue中的v-if和v-for不建议一起用？
在vue2当中，v-for的优先级大于v-if，则导致了在v-for进行列表渲染的时候，每一次渲染都会进行一次条件判断，比较浪费性能，所以不建议放在一起使用，可以在v-for的外层，嵌套一个template来进行条件渲染

在vue3当中，v-if的优先级大于v-for，但是也不建议放在一起使用，v-if放在外层的template上更加清晰明了

<hr>

## 2.8 SPA（单页应用）首屏加载速度慢怎么解决？
- 路由懒加载
- UI框架组件按需引入
- 开启GZip压缩
- 公共文件抽取公共打包模块
- 多个小图片时，制作雪碧图，减少网络请求
- 静态资源本地缓存
- 对一些依赖配置CDN加速

<hr>

## 2.9 为什么data属性是一个函数而不是一个对象？
vue实例当中的data可以是一个函数，也可以是一个对象，但是组件当中的data必须是一个函数，此函数返回了一个对象，因为实例只有一个，但是组件是复用的，如果组件的data是一个对象，那组件在复用的时候，就会造成数据的相互影响，所以组件的data必须是一个函数，这个函数返回的是一个新的对象，这样就避免了多个组件共享一个data的问题，避免了数据污染

<hr>

## 2.10 Vue中给对象添加新属性界面不刷新？
vue2当中使用的是Object.defineProperty来实现了对象的数据劫持，而Object.defineProperty只能监听到对象属性的setter和getter，并不能监听到对象属性的添加，我们可以使用Vue提供的set方法来完成此功能
- Vue.set() | vm.$set() | this.$set()

注意：vue3当中使用的是proxy来实现的响应式，直接添加新的属性是可以实现响应式的

<hr>

## 2.11 Vue组件间通信方式都有哪些？
- props / callBack 适用父子组件通信
- ref 与 $parent / $children 适用父子组件通信
- EventBus （$emit / $on） 适用于父子、隔代、兄弟组件通信
- 自定义事件 （$emit / $on）适用于父子组件通信
- $attrs/$listeners 适用于隔代组件通信
- provide / inject 适用于隔代组件通信
- vuex 适用于任意组件通信

<hr>

## 2.12 说说你对nextTick的理解？
vue当中修改数据之后，data当中的数据是立即发生变化的，但是页面上的数据还不是最新的，这是因为vue进行了优化处理，当我们修改数据后，并不是立即就触发视图的更新，而是会进行优化合并，统一进行一次的视图更新，但是这样导致了我们在更改数据之后，页面上的数据并不是最新的，我们可以使用this.$nextTick方法，在回调当中去获取到最新的dom

<hr>

## 2.13 说说你对vue的mixin的理解，有什么应用场景？
mixin即混入，mixin本身是一个简单的对象，可以包含data、method、生命周期函数等配置项。混入提供了一种复用代码的方式，我们可以把公共的方法和数据放到混入当中，这样每个组件都可以访问到混入当中的方法和数据了

vue当中分为全局混入和局部混入，全局混入会影响全部的组件，局部混入需要在组件内部进行配置，只会影响到当前组件。
混入的时候，同名的属性，会以组件当中的数据、方法为主，生命周期函数都会进行执行，先执行混入当中的，再执行组件内的

<hr>

## 2.14 说说你对slot的理解？slot使用场景有哪些？
slot即插槽，当我们在编写一些公共组件的时候，可以使用插槽，暴露出公共组件的某些位置，后续可以在调用的时候，进行补充和占位，使用插槽可以使得我们的组件有更好的扩展性，能够更好地复用。插槽分为：
- 默认插槽
- 具名插槽
- 作用域插槽

<hr>

## 2.15 Vue.observable你有了解过吗？
Vue.observable 让一个对象变成响应式数据，Vue内部会用它来处理data函数返回的对象，返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新，也可以作为最小化的跨组件状态存储器。我们可以使用这个方法来实现组件的通信

<hr>

## 2.16 你知道vue中key的原理吗？说说你对它的理解？
key是虚拟dom的标识，当数据发生变化的时候，vue会生成新的虚拟dom，随后进行新旧虚拟dom的比对。

对比规则：
- 当旧虚拟dom当中找到了key相同的节点时：
  > 如果dom当中的内容没有发生变化，则直接使用旧的真实dom，如果dom当中的内容发生了变化，则生成新的真实dom，替换掉页面上旧的真实dom
- 当旧虚拟dom当中未找到key相同的节点时：
  > 直接创建新的真实dom，随后渲染在页面当中

使用index作为key时会引发的问题：
- 如果对数据进行逆序添加、逆序删除，则会造成没有必要的真实dom更新，效率低下
- 如果结构当中还包含了输入框之类的dom，则会造成错误的dom更新，页面显示有问题

在进行v-for渲染的时候，如果不传递key属性，vue则会默认以index作为key的值；如果不涉及到数据的逆序添加、逆序删除，使用inde作为key也是可以的。

<hr>

## 2.17 怎么缓存当前的组件？缓存后怎么更新？说说你对keep-alive的理解是什么？
vue当中提供了一个内置组件keep-alive，使用keep-alive可以实现组件的缓存，keep-alive组件可以设置下面的属性：
- include 是一个数组，用于设置哪些组件需要被缓存
- exclude 是一个数组，用于设置哪些组不需要进行缓存
- max 是一个数字，用于设置最多可以缓存多少个组件

被keep-alive组件包裹的组件会多出两个生命周期函数，分别为activated和deactivated，这两个生命周期函数分别在组件激活和组件失活的时候被调用，可以利用这两个生命周期函数来实现缓存之后的页面更新。

## 2.18 Vue常用的修饰符有哪些？有什么应用场景？

<hr>

## 2.19 你有写过自定义指令吗？自定义指令的应用场景有哪些？
指令分为内置指令，如v-if/v-show/v-on/v-for等等，我们也可以使用Vue.directive来去编写自定义的指令，自定义的指令根据注册的位置分为全局指令和局部指令。在工作当中，可以通过自定义指令来封装某些公共逻辑，譬如：
- v-auth 使用自定义指令来实现按钮级别的权限
- v-focus 实现自动获取焦点
- v-copy 实现点击一键复制文本内容

<hr>

## 2.20 Vue中的过滤器了解吗？过滤器的应用场景有哪些？
过滤器即vue当中的filter，分为全局过滤器和局部过滤器，可以在模板和表达式当中使用管道符来使用；过滤器可以进行链式操作，后一个过滤器的参数，是上一个过滤器处理之后的结果。

我们可以使用过滤器来进行一些文本的格式化的操作，譬如金额千分化，时间戳格式化等；

在vue3当中，过滤器已经被废除了，我们可以使用methods当中的方法、计算属性、公共方法来去处理类似的情况

<hr>